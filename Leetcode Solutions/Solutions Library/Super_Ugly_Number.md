## Super Ugly Number
**Language:** python
**Tags:** python,oop,dynamic programming,multi-pointer

### Description:
<p>This Python code finds the <code>n</code>-th Super Ugly Number. A super ugly number is a positive number whose prime factors are only from a given list <code>primes</code>. The first super ugly number is 1.</p>
<hr>
<h3>1. Overview &amp; Intent</h3>
<p>The code implements a dynamic programming approach to find the <code>n</code>-th super ugly number. It iteratively builds a sorted list of super ugly numbers, starting from 1, by considering multiples of the given prime factors.</p>
<p><strong>Intent:</strong></p>
<ul>
<li>To efficiently compute the <code>n</code>-th number in the sequence where all prime factors of a number must be present in the <code>primes</code> list.</li>
</ul>
<hr>
<h3>2. How It Works</h3>
<p>The algorithm maintains three key lists to generate the super ugly numbers:</p>
<ol>
<li><strong><code>ugly</code></strong>: Stores the super ugly numbers found so far, up to <code>n</code> elements. <code>ugly[0]</code> is initialized to 1.</li>
<li><strong><code>indices</code></strong>: An array of pointers, one for each prime in <code>primes</code>. <code>indices[j]</code> indicates the index of the <code>ugly</code> number that <code>primes[j]</code> is currently being multiplied with.</li>
<li><strong><code>next_ugly</code></strong>: An array storing the next candidate super ugly number generated by each prime. <code>next_ugly[j]</code> holds <code>ugly[indices[j]] * primes[j]</code>.</li>
</ol>
<p>The process is as follows:</p>
<ul>
<li><strong>Initialization</strong>:<ul>
<li><code>ugly[0]</code> is set to 1.</li>
<li><code>indices</code> are all set to 0, meaning each prime initially multiplies <code>ugly[0]</code> (which is 1).</li>
<li><code>next_ugly</code> is initialized with <code>primes[j] * ugly[0]</code> (i.e., <code>primes[j]</code>).</li>
</ul>
</li>
<li><strong>Iteration (from the 2nd to the <code>n</code>-th ugly number)</strong>:<ul>
<li>In each step, the algorithm finds the <code>min_val</code> from the <code>next_ugly</code> candidates list. This <code>min_val</code> is the next super ugly number.</li>
<li><code>ugly[i]</code> is set to <code>min_val</code>.</li>
<li>Then, it iterates through <code>next_ugly</code> to identify <em>all</em> primes that generated this <code>min_val</code>.</li>
<li>For each prime <code>primes[j]</code> that contributed to <code>min_val</code>:<ul>
<li>Its <code>indices[j]</code> pointer is incremented (moving to the next known super ugly number).</li>
<li><code>next_ugly[j]</code> is updated to <code>ugly[indices[j]] * primes[j]</code>, generating a new candidate for that prime.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Result</strong>: After <code>n-1</code> iterations, <code>ugly[n-1]</code> holds the <code>n</code>-th super ugly number.</li>
</ul>
<hr>
<h3>3. Key Design Decisions</h3>
<ul>
<li><strong>Dynamic Programming</strong>: The solution builds up the sequence of super ugly numbers from the first to the <code>n</code>-th. Each <code>ugly[i]</code> depends on previously computed <code>ugly</code> numbers.</li>
<li><strong>Multiple Pointers (<code>indices</code>)</strong>: This is the core of the algorithm. By maintaining a pointer for each prime, it ensures that all potential candidates (previous ugly number multiplied by a prime) are considered in a sorted fashion without needing to re-sort a global list of candidates repeatedly. When a candidate <code>ugly[indices[j]] * primes[j]</code> is used, <code>indices[j]</code> is advanced to consider <code>ugly[indices[j]+1] * primes[j]</code>.</li>
<li><strong><code>next_ugly</code> List</strong>: This list stores the <em>current smallest candidate</em> for each prime. Finding the minimum of this list at each step is efficient and directly gives the next overall super ugly number.</li>
<li><strong>Handling Duplicates in <code>next_ugly</code></strong>: If multiple primes can generate the same <code>min_val</code> (e.g., 6 can be <code>2 * 3</code> and <code>3 * 2</code>), the inner loop correctly identifies <em>all</em> such primes and advances their respective <code>indices</code>. This is crucial for correctness, ensuring no future candidates are missed.</li>
</ul>
<hr>
<h3>4. Complexity</h3>
<p>Let <code>n</code> be the target number (index) and <code>k</code> be the number of prime factors (<code>len(primes)</code>).</p>
<ul>
<li><p><strong>Time Complexity</strong>:</p>
<ul>
<li>Initialization: <code>ugly</code> list takes O(n), <code>indices</code> and <code>next_ugly</code> take O(k).</li>
<li>Main loop runs <code>n-1</code> times.</li>
<li>Inside the loop:<ul>
<li><code>min(next_ugly)</code> takes O(k) time.</li>
<li>The subsequent inner loop iterates <code>k</code> times.</li>
<li>Total for each iteration: O(k) + O(k) = O(k).</li>
</ul>
</li>
<li>Overall: O(n*k).</li>
</ul>
</li>
<li><p><strong>Space Complexity</strong>:</p>
<ul>
<li><code>ugly</code>: O(n) to store the sequence of super ugly numbers.</li>
<li><code>indices</code>: O(k) for the pointers.</li>
<li><code>next_ugly</code>: O(k) for the current candidates.</li>
<li>Overall: O(n + k).</li>
</ul>
</li>
</ul>
<hr>
<h3>5. Edge Cases &amp; Correctness</h3>
<ul>
<li><strong><code>n = 1</code></strong>: Handled by an explicit base case, returning 1. This is correct as 1 is the first super ugly number by definition.</li>
<li><strong>Empty <code>primes</code> list</strong>: Not typically allowed by problem constraints (usually <code>len(primes) &gt;= 1</code>). If <code>primes</code> were empty, <code>k</code> would be 0, <code>next_ugly</code> would be empty, and <code>min(next_ugly)</code> would raise an error.</li>
<li><strong><code>primes</code> containing non-prime numbers</strong>: The algorithm would still function correctly based on the problem definition (factors <em>from the given list</em>), though the numbers generated might not strictly adhere to the mathematical definition of "super ugly" if the list isn't truly prime. Assuming <code>primes</code> contains valid prime numbers.</li>
<li><strong><code>primes</code> containing 1</strong>: If 1 were in <code>primes</code>, it would always generate the same number (<code>ugly[indices[j]] * 1</code>), and <code>indices[j]</code> for that prime would never need to advance for new candidates. The <code>min()</code> logic would ensure other primes are chosen first, so it doesn't break. Standard problem statements usually provide primes &gt; 1.</li>
<li><strong>Duplicate primes in <code>primes</code></strong>: E.g., <code>primes = [2, 3, 2]</code>. The algorithm would treat them as distinct sources for candidates. <code>next_ugly</code> would have two entries for 2, both tracked independently. This is correct but slightly redundant in computation.</li>
<li><strong>Collisions (multiple paths to the same number)</strong>: E.g., <code>n = 4, primes = [2, 3]</code>. <code>ugly = [1, 2, 3, 4]</code>. If <code>primes = [2,3,5]</code>, 6 can be <code>2*3</code> and <code>3*2</code>. The inner loop <code>for j in range(k): if next_ugly[j] == min_val:</code> correctly identifies <em>all</em> prime sources that generated the current <code>min_val</code> and increments their respective <code>indices</code>. This ensures all pointers advance as necessary, maintaining correctness.</li>
</ul>
<hr>
<h3>6. Improvements &amp; Alternatives</h3>
<ol>
<li><p><strong>Min-Heap (Priority Queue) for <code>next_ugly</code></strong>:</p>
<ul>
<li><strong>Current approach</strong>: Finding <code>min(next_ugly)</code> takes O(k).</li>
<li><strong>Improvement</strong>: Using a min-heap (<code>heapq</code> in Python) to store the <code>(candidate_value, prime_index)</code> tuples.<ul>
<li><code>heapq.heappop()</code> takes O(log k) to get the minimum.</li>
<li><code>heapq.heappush()</code> takes O(log k) to add a new candidate.</li>
</ul>
</li>
<li>This would reduce the overall time complexity from O(n*k) to <strong>O(n log k)</strong>.</li>
<li><strong>Caveat</strong>: When using a heap, one needs to carefully handle the case where multiple primes generate the same <code>min_val</code> at different times. If <code>min_val</code> is popped from the heap, the current code's <code>ugly[i] = min_val</code> ensures it's stored only once. With a heap, if <code>min_val</code> is equal to <code>ugly[i-1]</code> (meaning it was already added via another prime path), you should simply process the next candidate from the heap without incrementing <code>i</code> or adding to <code>ugly</code>.</li>
</ul>
<pre><code class="language-python">import heapq
from typing import List

class Solution:
    def nthSuperUglyNumber_heap(self, n: int, primes: List[int]) -&gt; int:
        if n == 1:
            return 1

        ugly = [1]
        k = len(primes)
        indices = [0] * k # Pointer for each prime
        
        # Min-heap stores (candidate_value, prime_index)
        # Initial candidates are primes[j] * ugly[0]
        heap = [(p, j) for j, p in enumerate(primes)]
        heapq.heapify(heap)

        while len(ugly) &lt; n:
            min_val, prime_idx = heapq.heappop(heap)
            
            # Skip if this value is a duplicate of the last ugly number added
            if min_val == ugly[-1]:
                # Push the next candidate for this prime and continue
                indices[prime_idx] += 1
                next_candidate = ugly[indices[prime_idx]] * primes[prime_idx]
                heapq.heappush(heap, (next_candidate, prime_idx))
                continue # Try again with the next smallest from the heap

            ugly.append(min_val)
            
            # Advance the pointer for the prime that generated min_val
            indices[prime_idx] += 1
            
            # Calculate and push the next candidate for this prime
            next_candidate = ugly[indices[prime_idx]] * primes[prime_idx]
            heapq.heappush(heap, (next_candidate, prime_idx))
                
        return ugly[n - 1]
</code></pre>
</li>
<li><p><strong>Readability</strong>: The current code is quite readable. Variable names are descriptive. Comments are helpful. No significant readability improvements are necessary.</p>
</li>
</ol>
<hr>
<h3>7. Security/Performance Notes</h3>
<ul>
<li><strong>Performance</strong>: As mentioned, for large <code>n</code> and <code>k</code>, the <code>O(n*k)</code> complexity might lead to Time Limit Exceeded errors in competitive programming contexts. The <code>O(n log k)</code> heap-based approach would be more performant.</li>
<li><strong>Integer Overflow</strong>: <code>super ugly numbers</code> can grow very large. Python's integers automatically handle arbitrary precision, so overflow is not an issue. In languages like C++ or Java, <code>long long</code> or <code>BigInteger</code> might be necessary for large <code>n</code> or <code>primes</code>.</li>
</ul>


### Code:
```python
from typing import List

class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        # The 1st super ugly number is 1
        if n == 1:
            return 1

        # Initialize with the 1st ugly number (1).
        ugly = [1] * n
        
        # Number of prime factors
        k = len(primes)
        

        indices = [0] * k
        

        next_ugly = list(primes) # Initial candidates: 1 * primes[j]
        

        for i in range(1, n):
            # Find the minimum of all current candidates
            min_val = min(next_ugly)
            
            # The next super ugly number is this minimum value
            ugly[i] = min_val
            

            for j in range(k):
                if next_ugly[j] == min_val:
                    # Increment the index of the super ugly number
                    indices[j] += 1
                    # Calculate the next candidate for this prime
                    next_ugly[j] = ugly[indices[j]] * primes[j]
                    
        # The nth super ugly number is at index n-1
        return ugly[n - 1]
```
